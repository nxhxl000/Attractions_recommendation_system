# backend/db_init.py
import os
import logging
from sqlalchemy import create_engine, text
from sqlalchemy.exc import SQLAlchemyError
from dotenv import load_dotenv

# -----------------------------
# ЛОГИРОВАНИЕ (RU)
# -----------------------------
logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
log = logging.getLogger("db_init")

# -----------------------------
# ЗАГРУЗКА .env
# -----------------------------
load_dotenv()  # подтянет DATABASE_URL из .env

DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise SystemExit("❌ Ошибка: переменная окружения DATABASE_URL не задана. "
                     "Укажите её в .env (postgresql+psycopg2://...)?sslmode=require")

engine = create_engine(DATABASE_URL, pool_pre_ping=True, future=True)

# -----------------------------
# SQL
# -----------------------------
DDL_CREATE = """
CREATE TABLE IF NOT EXISTS public.attractions (
  id   INTEGER PRIMARY KEY,
  name TEXT NOT NULL
);

COMMENT ON TABLE public.attractions IS 'Достопримечательности (минимум: id, name)';
COMMENT ON COLUMN public.attractions.id IS 'Первичный ключ';
COMMENT ON COLUMN public.attractions.name IS 'Название достопримечательности';
"""

CHECK_IDENTITY = """
SELECT is_identity
FROM information_schema.columns
WHERE table_schema = 'public'
  AND table_name = 'attractions'
  AND column_name = 'id';
"""

ALTER_TO_IDENTITY = """
ALTER TABLE public.attractions
  ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY;
"""

GET_SEQ_NAME = """
SELECT pg_get_serial_sequence('public.attractions','id') AS seq;
"""

SYNC_SEQ = """
SELECT setval(:seq,
              COALESCE((SELECT MAX(id) FROM public.attractions), 1),
              true);
"""

INSERTS = [
    ("INSERT INTO public.attractions (id, name) VALUES (:id, :name) ON CONFLICT (id) DO NOTHING",
     {"id": 1, "name": "Старый замок"}),
    ("INSERT INTO public.attractions (id, name) VALUES (:id, :name) ON CONFLICT (id) DO NOTHING",
     {"id": 2, "name": "Городской парк"}),
]

def ensure_table_and_identity():
    """Создаёт таблицу и гарантирует авто-генерацию id."""
    with engine.begin() as conn:
        log.info("Создаю таблицу public.attractions (если её нет)...")
        conn.execute(text(DDL_CREATE))

        log.info("Проверяю, что столбец id — IDENTITY...")
        row = conn.execute(text(CHECK_IDENTITY)).one_or_none()
        is_identity = (row and row[0] == 'YES')

        if not is_identity:
            log.info("Столбец id не является IDENTITY. Применяю миграцию...")
            conn.execute(text(ALTER_TO_IDENTITY))
            log.info("Миграция завершена: id теперь GENERATED BY DEFAULT AS IDENTITY.")
        else:
            log.info("Столбец id уже IDENTITY — миграция не требуется.")

        # Синхронизация последовательности с актуальным MAX(id)
        log.info("Синхронизирую последовательность для id...")
        seq_row = conn.execute(text(GET_SEQ_NAME)).one()
        seq_name = seq_row[0]
        if not seq_name:
            # На всякий случай: у identity должна быть последовательность.
            raise RuntimeError("Не удалось определить имя последовательности для id.")
        conn.execute(text(SYNC_SEQ), {"seq": seq_name})
        log.info("Последовательность %s синхронизирована.", seq_name)

def seed_initial_data():
    """Добавляет две стартовые записи (идемпотентно)."""
    with engine.begin() as conn:
        log.info("Добавляю стартовые данные (2 записи)...")
        for sql, params in INSERTS:
            conn.execute(text(sql), params)
    log.info("Стартовые записи готовы (если их не было).")

def main():
    try:
        ensure_table_and_identity()
        seed_initial_data()
    except SQLAlchemyError as e:
        log.error("Ошибка работы с БД: %s", str(e))
        raise SystemExit(1)
    except Exception as e:
        log.error("Непредвиденная ошибка: %s", str(e))
        raise SystemExit(1)
    else:
        log.info("✅ Готово: таблица и авто-ID настроены, данные добавлены.")

if __name__ == "__main__":
    main()
